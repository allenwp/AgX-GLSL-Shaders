(*
Copyright (c) 2025 Allen Pestaluky
Based on Timothy Lottes' tone curve and Reinhard tone curve, \
aims to match EaryChow's AgX tone curve.
 *)
<< FunctionApproximations`

kNormLog2Min = -10;
kNormLog2Max = Rationalize[6.5];
kMidGray = Rationalize[0.18];
kLog2Min = Log2[(2^kNormLog2Min)*kMidGray];
kLog2Max = Log2[(2^kNormLog2Max)*kMidGray];
kLinearMin = (2^kNormLog2Min)*kMidGray;
kLinearMax = (2^kNormLog2Max)*kMidGray;
kPower = Rationalize[1.5];
kSlope = Rationalize[2.4];
kXPivot = Abs[kNormLog2Min/(kNormLog2Max - kNormLog2Min)];
kYPivot = kMidGray^(Rationalize[1.0/2.4]);

equationScale[transitionX_, transitionY_, power_, slope_] := 
  Module[{termA, termB}, 
   termA = (slope*(Rationalize[1 - transitionX]))^(Rationalize[-1*
        power]);
   termB = 
    SetPrecision[((slope*(Rationalize[1 - transitionX]))/(Rationalize[
           1 - transitionY]))^(power) - 1, 20];
   (termA*termB)^(Rationalize[-1/power])];

exponentialCurve[x_, scaleInput_, xPivot_, yPivot_, power_, 
  slope_] := (scaleInput*
    exponential[(slope*(x - xPivot))/scaleInput, power]) + yPivot

exponential[x_, power_] := x/((1 + (x^power))^(1/power))

calculateSigmoid[x_, xPivot_, yPivot_] := 
  Module[{scaleValue}, 
   scaleValue = 
    If[x < xPivot, -1*
      equationScale[1.0 - xPivot, 1.0 - yPivot, kPower, kSlope], 
     equationScale[xPivot, yPivot, kPower, kSlope]];
   exponentialCurve[x, scaleValue, xPivot, yPivot, kPower, kSlope]];

agxCurve[x_] := 
  Module[{normalizedX}, 
   normalizedX = (Log2[x/kMidGray] - kNormLog2Min)/(kNormLog2Max - 
       kNormLog2Min);
   calculateSigmoid[normalizedX, kXPivot, kYPivot]^kSlope];

Print[Style["Reference Curve", "Section"]]
Print["AgX tonemapping curve:"]
agxReferencePlot = 
 Plot[agxCurve[x], {x, kLinearMin, kLinearMax}, 
  ScalingFunctions -> {"Log2", None}, PlotStyle -> Gray]

Print[Style["Toe Calculations", "Section"]]
Print["Part of Timothy Lottes' tonemapping equation for the toe:"]
Print["Generic soultion for toeA:"]
tonemapToe[x_, contrast_] := (x^contrast)/((x^contrast) + toeA);
FullSimplify[Solve[{tonemapToe[midIn, contrast] == midOut}, {toeA}]]

Print["Soultion for toeA with hardcoded mid grey:"]
SetPrecision[
 FullSimplify[
  Solve[{tonemapToe[N[kMidGray], contrast] == 
     N[kMidGray]}, {toeA}]], 15]
Print["41/9 == 4.555 repeating, so this is equivalent to: (41/9)*\!\(\
\*SuperscriptBox[\(kMidGray\), \(contrast\)]\) or:"]
(41/9)* (kMidGray^contrast)

Print["NonlinearModelFit using solution for toeA from previous step. \
Range of toe only."]
dataToe = 
  Table[{x, agxCurve[x]}, {x, 
    2^Range[Log2[kLinearMin], Log2[kMidGray], 0.001]}];
nlmToe = 
  SetPrecision[
   NonlinearModelFit[
    dataToe, (x^
       contrast)/((x^contrast) + (41 9^(-1 + contrast)
          50^-contrast)), {contrast}, x], 15];
nlmfToeResult = Normal[nlmToe]
toePlot = 
  Plot[nlmfToeResult, {x, kLinearMin, kMidGray}, 
   ScalingFunctions -> {"Log2", None}];
Show[toePlot, agxReferencePlot]

Print[Style["Slope Calculations", "Subsection"]]
Print["Target slope at mid gray:"]
N[D[agxCurve[x], x] /. x -> kMidGray]

Print["Slope of flitted curve toe:"]
D[nlmToe[x], x] /. x -> kMidGray

basicToe[x_] := (x^1.25)/((x^1.25) + (41 9^(-1 + 1.25) 50^-1.25));
Print["Slope of 1.25 contrast toe:"]
D[basicToe[x], x] /. x -> kMidGray

Print["Derivative function at midIn (slope at midIn):"]
toeFunc[midIn_, contrast_, 
   toeA_] = (midIn^contrast)/(midIn^contrast + toeA);
FullSimplify[D[toeFunc[midIn, contrast, toeA], midIn]]

Print["Sanity check of slope of fitted curve toe using general \
derivative:"]
slopeFunc[midIn_, contrast_, toeA_] := (
  contrast midIn^(-1 + contrast) toeA)/(midIn^contrast + toeA)^2;
slopeFunc[kMidGray, 
  contrast, -((kMidGray^contrast (-1 + kMidGray))/kMidGray)] /. 
 contrast -> 1.25652780401490971051714495843043550849`15.

Print[Style["Shoulder Calculations", "Section"]]
tonemapShoulder[xIn_, midIn_, midOut_, white_, maxVal_, slope_, 
   shoulder_, c_] := Module[{x, shoulderMaxVal, w, result},
   shoulderMaxVal = maxVal - midOut;
   x = xIn;
   x = x - midIn;
   x = slope*
     x*(shoulder + x/(c*slope))/(shoulder + (x*slope)/shoulderMaxVal);
   x = x + midOut;
   x
   ];
Print["Generic shoulder function with shoulder paramter:"]
FullSimplify[
 tonemapShoulder[x, midIn, midOut, white, maxVal, slope, shoulder, c]]
Print["Solution for c such that input of white always results in \
output of maxVal:"]
FullSimplify[
 Solve[{tonemapShoulder[white, midIn, midOut, white, maxVal, slope, 
     shoulder, c] == maxVal}, {c}]]
Print["Shoulder with hardcoded parameters:"]
hardcodedSlopeShoulder = 
 FullSimplify[
  tonemapShoulder[x, midIn, midOut, white, maxVal, (
    contrast midIn^(-1 + contrast) toeA)/(midIn^contrast + toeA)^2, 
    shoulder, (midIn - white)^2/(
    maxVal shoulder - 
     midOut shoulder + (-1 + shoulder) (
      contrast midIn^(-1 + contrast)
        toeA)/(midIn^contrast + toeA)^2 (midIn - 
        white))] /. {toeA -> -((
      kMidGray^1.25652780401490971051714495843043550849`15. (-1 + 
         kMidGray))/kMidGray), midIn -> kMidGray, midOut -> kMidGray, 
    white -> kLinearMax, maxVal -> 1.0, 
    contrast -> 1.25652780401490971051714495843043550849`15.}]

Print["NonlinearModelFit using solution for c from previous step and \
slope from above. Range of shoulder only."]
dataShoulder = 
  Table[{x, agxCurve[x]}, {x, 
    2^Range[Log2[kMidGray], Log2[kLinearMax], 0.001]}];
nlmShoulder = 
  SetPrecision[
   NonlinearModelFit[
    dataShoulder, (-0.03863950675119501` + (0.20315284806837197` + 
          0.06395043515086599` x) x + 
       shoulder (-0.007433151244207792` + (1.0522377700878607` - 
             0.06079158554343046` x) x))/(-0.22617500472268373` + 
       shoulder + 1.2565278040149097` x), {shoulder}, x], 15];
nlmShoulder["BestFitParameters"]
nlmfShoulderResult = FullSimplify[Normal[nlmShoulder]]
shoulderPlot = 
  Plot[nlmfShoulderResult, {x, kMidGray, kLinearMax}, 
   ScalingFunctions -> {"Log2", None}];
Show[shoulderPlot, agxReferencePlot]

Print[Style["Various constants:", "Section"]]
Print["linear min:"]
N[kLinearMin, 20]
Print["linear max:"]
N[kLinearMax, 20]
Print["log2 min:"]
N[kLog2Min, 20]
Print["log2 max:"]
N[kLog2Max, 20]

Print["agxCurve at min:"]
agxCurve[kLinearMin]
Print["agxCurve at middle grey:"]
N[agxCurve[kMidGray]]
Print["agxCurve at max:"]
agxCurve[kLinearMax]