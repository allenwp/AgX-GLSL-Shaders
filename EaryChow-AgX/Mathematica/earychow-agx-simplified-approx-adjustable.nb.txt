(*
Copyright (c) 2025 Allen Pestaluky
Based on Timothy Lottes' tone curve and Reinhard tone curve.
 *)
<< FunctionApproximations`

kNormLog2Min = -10;
kNormLog2Max = Rationalize[6.5];
kMidGray = Rationalize[0.18];
kLog2Min = Log2[(2^kNormLog2Min)*kMidGray];
kLog2Max = Log2[(2^kNormLog2Max)*kMidGray];
kLinearMin = (2^kNormLog2Min)*kMidGray;
kLinearMax = (2^kNormLog2Max)*kMidGray;
kPower = Rationalize[1.5];
kSlope = Rationalize[2.4];
kXPivot = Abs[kNormLog2Min/(kNormLog2Max - kNormLog2Min)];
kYPivot = kMidGray^(Rationalize[1.0/2.4]);

equationScale[transitionX_, transitionY_, power_, slope_] := 
  Module[{termA, termB}, 
   termA = (slope*(Rationalize[1 - transitionX]))^(Rationalize[-1*
        power]);
   termB = 
    SetPrecision[((slope*(Rationalize[1 - transitionX]))/(Rationalize[
           1 - transitionY]))^(power) - 1, 20];
   (termA*termB)^(Rationalize[-1/power])];

exponentialCurve[x_, scaleInput_, xPivot_, yPivot_, power_, 
  slope_] := (scaleInput*
    exponential[(slope*(x - xPivot))/scaleInput, power]) + yPivot

exponential[x_, power_] := x/((1 + (x^power))^(1/power))

calculateSigmoid[x_, xPivot_, yPivot_] := 
  Module[{scaleValue}, 
   scaleValue = 
    If[x < xPivot, -1*
      equationScale[1.0 - xPivot, 1.0 - yPivot, kPower, kSlope], 
     equationScale[xPivot, yPivot, kPower, kSlope]];
   exponentialCurve[x, scaleValue, xPivot, yPivot, kPower, kSlope]];

agxCurve[x_] := 
  Module[{normalizedX}, 
   normalizedX = (Log2[x/kMidGray] - kNormLog2Min)/(kNormLog2Max - 
       kNormLog2Min);
   calculateSigmoid[normalizedX, kXPivot, kYPivot]^kSlope];

Print[Style["Reference Curve", "Section"]]
Print["AgX tonemapping curve:"]
agxReferencePlot = 
 Plot[agxCurve[x], {x, kLinearMin, kLinearMax}, 
  ScalingFunctions -> {"Log2", None}, PlotStyle -> Gray]

Print[Style["Toe Calculations", "Section"]]
Print["Part of Timothy Lottes' tonemapping equation for the toe:"]
Print["Generic soultion for toeA:"]
tonemapToe[x_, contrast_] := (x^contrast)/((x^contrast) + toeA);
FullSimplify[Solve[{tonemapToe[midIn, contrast] == midOut}, {toeA}]]

Print["Soultion for toeA with hardcoded mid grey:"]
SetPrecision[
 FullSimplify[
  Solve[{tonemapToe[N[kMidGray], contrast] == 
     N[kMidGray]}, {toeA}]], 15]
Print["41/9 == 4.555 repeating, so this is equivalent to:"]
FullSimplify[41/9* kMidGray^contrast]

Print["NonlinearModelFit using solution for toeA from previous step. \
Range of toe only."]
dataToe = 
  Table[{x, agxCurve[x]}, {x, 
    2^Range[Log2[kLinearMin], Log2[kMidGray], 0.001]}];
nlmToe = 
  SetPrecision[
   NonlinearModelFit[
    dataToe, (x^
       contrast)/((x^contrast) + (41 9^(-1 + contrast)
          50^-contrast)), {contrast}, x], 15];
nlmfToeResult = Normal[nlmToe]
toePlot = Plot[nlmfToeResult, {x, kLinearMin, kMidGray}];
Show[toePlot, agxReferencePlot]

Print[Style["Slope Calculations", "Subsection"]]
Print["Target slope at mid gray:"]
N[D[agxCurve[x], x] /. x -> kMidGray]

Print["Slope of flitted curve toe:"]
D[nlmToe[x], x] /. x -> kMidGray

Print["Derivative function at midIn (slope at midIn):"]
toeFunc[midIn_, contrast_, 
   toeA_] = (midIn^contrast)/(midIn^contrast + toeA);
FullSimplify[D[toeFunc[midIn, contrast, toeA], midIn]]

Print["Sanity check of slope of fitted curve toe using general \
derivative:"]
slopeFunc[midIn_, contrast_, toeA_] := (
  contrast midIn^(-1 + contrast) toeA)/(midIn^contrast + toeA)^2;
slopeFunc[kMidGray, 
  contrast, -((kMidGray^contrast (-1 + kMidGray))/kMidGray)] /. 
 contrast -> 1.25652780401490971051714495843043550849`15.

Print[Style["Shoulder Calculations", "Section"]]
tonemapShoulder[x_, midIn_, midOut_, white_, maxVal_, slope_, 
   shoulder_, c_] := Module[{shoulderMaxVal, w, result},
   (*toeA=-((midIn^contrast (-1+midOut))/midOut);
   slope=(midIn^(-1+contrast) toeA contrast)/(midIn^contrast+toeA)^2;*)
   shoulderMaxVal = maxVal - midOut;
   w = white - midIn;
   w = w*w;
   w = w/shoulderMaxVal;
   w = w*slope;
   result = x - midIn;
   result = 
    slope*result*(c + 
        result/w)/(c + (result^shoulder*slope)/shoulderMaxVal);
   result = result + midOut;
   result
   ];
Print["Generic shoulder function with shoulder paramter:"]
FullSimplify[
 tonemapShoulder[x, midIn, midOut, white, maxVal, slope, shoulder, c]]
Print["Solution for c such that input of white always results in outpu\
t of maxVal:"]
FullSimplify[
 Solve[{tonemapShoulder[white, midIn, midOut, white, maxVal, slope, 
     shoulder, c] == maxVal}, {c}]]
Print["Shoulder with hardcoded slope:"]
hardcodedSlopeShoulder = 
 FullSimplify[
  tonemapShoulder[x, kMidGray, kMidGray, kLinearMax, 1.0, (
    41 9^(1 + contrast) 50^contrast kMidGray^(-1 + contrast)
      contrast)/(41 9^contrast + 9 50^contrast kMidGray^contrast)^2, 
    shoulder, (-kLinearMax + 
     kMidGray + (
      41 9^(1 + contrast) 50^contrast kMidGray^(-1 + contrast)
        contrast)/(41 9^contrast + 
        9 50^contrast kMidGray^contrast)^2 (-kMidGray + 1)^
      shoulder)/(-kLinearMax + 
     kMidGray + (
      41 9^(1 + contrast) 50^contrast kMidGray^(-1 + contrast)
        contrast)/(41 9^contrast + 
        9 50^contrast kMidGray^contrast)^2 (-kMidGray + 1))] /. 
   contrast -> 1.25652780401490971051714495843043550849`15.]

Print["NonlinearModelFit using solution for c from previous step and s\
lope from above. Range of shoulder only."]
dataShoulder = 
  Table[{x, agxCurve[x]}, {x, 
    2^Range[Log2[kMidGray], Log2[kLinearMax], 0.001]}];
nlmShoulder = 
  SetPrecision[
   NonlinearModelFit[dataShoulder, 
    0.18` + (41^
         shoulder (-0.18546350387260066` + 1.0303527992922261` x) + 
        50^shoulder (2.898596760202988` + (-16.094890430384027` - 
              0.0468050226500802` x) x))/(1.` 41^shoulder - 
        15.637110171977595` 50^shoulder - 
        18.618110906241984` (-9 + 50 x)^shoulder), {shoulder}, x], 15];
nlmfShoulderResult = FullSimplify[Normal[nlmShoulder]]
shoulderPlot = 
  Plot[nlmfShoulderResult, {x, kMidGray, kLinearMax}, 
   ScalingFunctions -> {"Log2", None}];
Show[shoulderPlot, agxReferencePlot]

Print[Style["Various constants:", "Section"]]
Print["linear min:"]
N[kLinearMin, 20]
Print["linear max:"]
N[kLinearMax, 20]
Print["log2 min:"]
N[kLog2Min, 20]
Print["log2 max:"]
N[kLog2Max, 20]

Print["agxCurve at min:"]
agxCurve[kLinearMin]
Print["agxCurve at middle grey:"]
N[agxCurve[kMidGray]]
Print["agxCurve at max:"]
agxCurve[kLinearMax]