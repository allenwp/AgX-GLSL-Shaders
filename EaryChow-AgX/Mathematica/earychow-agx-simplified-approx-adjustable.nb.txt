(*
Copyright (c) 2025 Allen Pestaluky
Based on Timothy Lottes' tone curve and Reinhard tone curve.
 *)
<< FunctionApproximations`

kNormLog2Min = -10;
kNormLog2Max = Rationalize[6.5];
kMidGray = Rationalize[0.18];
kLog2Min = Log2[(2^kNormLog2Min)*kMidGray];
kLog2Max = Log2[(2^kNormLog2Max)*kMidGray];
kLinearMin = (2^kNormLog2Min)*kMidGray;
kLinearMax = (2^kNormLog2Max)*kMidGray;
kPower = Rationalize[1.5];
kSlope = Rationalize[2.4];
kXPivot = Abs[kNormLog2Min/(kNormLog2Max - kNormLog2Min)];
kYPivot = kMidGray^(Rationalize[1.0/2.4]);

equationScale[transitionX_, transitionY_, power_, slope_] := 
  Module[{termA, termB}, 
   termA = (slope*(Rationalize[1 - transitionX]))^(Rationalize[-1*
        power]);
   termB = 
    SetPrecision[((slope*(Rationalize[1 - transitionX]))/(Rationalize[
           1 - transitionY]))^(power) - 1, 20];
   (termA*termB)^(Rationalize[-1/power])];

exponentialCurve[x_, scaleInput_, xPivot_, yPivot_, power_, 
  slope_] := (scaleInput*
    exponential[(slope*(x - xPivot))/scaleInput, power]) + yPivot

exponential[x_, power_] := x/((1 + (x^power))^(1/power))

calculateSigmoid[x_, xPivot_, yPivot_] := 
  Module[{scaleValue}, 
   scaleValue = 
    If[x < xPivot, -1*
      equationScale[1.0 - xPivot, 1.0 - yPivot, kPower, kSlope], 
     equationScale[xPivot, yPivot, kPower, kSlope]];
   exponentialCurve[x, scaleValue, xPivot, yPivot, kPower, kSlope]];

agxCurve[x_] := 
  Module[{normalizedX}, 
   normalizedX = (Log2[x/kMidGray] - kNormLog2Min)/(kNormLog2Max - 
       kNormLog2Min);
   calculateSigmoid[normalizedX, kXPivot, kYPivot]^kSlope];

Print[Style["Reference Curve", "Section"]]
Print["AgX tonemapping curve:"]
Plot[agxCurve[x], {x, kLinearMin, kLinearMax}, 
 ScalingFunctions -> {"Log2", None}]

Print[Style["Toe Calculations", "Section"]]
Print["Part of Timothy Lottes' tonemapping equation for the toe:"]
Print["Generic soultion for toeA:"]
tonemapToe[x_, contrast_] := (x^contrast)/((x^contrast) + toeA);
FullSimplify[Solve[{tonemapToe[midIn, contrast] == midOut}, {toeA}]]

Print["Soultion for toeA with hardcoded mid grey:"]
SetPrecision[
 FullSimplify[
  Solve[{tonemapToe[N[kMidGray], contrast] == 
     N[kMidGray]}, {toeA}]], 15]
Print["41/9 == 4.555 repeating, so this is equivalent to:"]
FullSimplify[41/9* kMidGray^contrast]

Print["NonlinearModelFit using solution for toeA from previous step. \
Range of toe only."]
dataToe = 
  Table[{x, agxCurve[x]}, {x, 
    2^Range[Log2[kLinearMin], Log2[kMidGray], 0.001]}];
nlmToe = 
  SetPrecision[
   NonlinearModelFit[
    dataToe, (x^
       contrast)/((x^contrast) + (41 9^(-1 + contrast)
          50^-contrast)), {contrast}, x], 15];
nlmfToeResult = Normal[nlmToe]
Plot[nlmfToeResult, {x, kLinearMin, kMidGray}]

Print[Style["Slope Calculations", "Subsection"]]
Print["Target slope at mid gray:"]
N[D[agxCurve[x], x] /. x -> kMidGray]

Print["Slope of flitted curve toe:"]
D[nlmToe[x], x] /. x -> kMidGray

Print["Derivative function at midIn (slope at midIn):"]
toeFunc[midIn_, toeContrast_, 
   toeA_] = (midIn^toeContrast)/(midIn^toeContrast + toeA);
slopeFunc[midIn, toeContrast] = 
 FullSimplify[
  D[toeFunc[midIn, toeContrast, 
    41 9^(-1 + toeContrast) 50^-toeContrast], midIn]]

Print[Style["Shoulder Calculations", "Section"]]
tonemapShoulder[x_, midIn_, midOut_, white_, maxVal_, slope_, 
   shoulder_, c_] := Module[{shoulderMaxVal, w, result},
   (*toeA=-((midIn^toeContrast (-1+midOut))/midOut);
   slope=(midIn^(-1+toeContrast) toeA toeContrast)/(midIn^toeContrast+
   toeA)^2;*)
   shoulderMaxVal = maxVal - midOut;
   w = white - midIn;
   w = w*w;
   w = w/shoulderMaxVal;
   w = w*slope;
   result = x - midIn;
   result = 
    slope*result*(c + 
        result/w)/(c + (result^shoulder*slope)/shoulderMaxVal);
   result = result + midOut;
   result
   ];
Print["Generic shoulder function with shoulder paramter:"]
FullSimplify[
 tonemapShoulder[x, midIn, midOut, white, maxVal, slope, shoulder, c]]
Print["Solution for c such that input of white always results in \
output of maxVal:"]
FullSimplify[
 Solve[{tonemapShoulder[white, midIn, midOut, white, maxVal, slope, 
     shoulder, c] == maxVal}, {c}]]

Print["NonlinearModelFit using solution for c from previous step. \
Range of shoulder only."]
Print["This uses log2 scale from the minimum AgX value to linear value\
 of 2.0."]
Print["This range was chosen because linear values below 2.\
0 are preceptually most important."]
dataShoulder = 
  Table[{x, agxCurve[x]}, {x, 
    2^Range[Log2[kMidGray], Log2[kLinearMax], 0.001]}];
nlmShoulder = 
  SetPrecision[
   NonlinearModelFit[dataShoulder, shoulder, {shoulder}, x], 15];
nlmfShoulderResult = Normal[nlmShoulder]
Plot[nlmfShoulderResult, {x, kMidGray, kLinearMax}, 
 ScalingFunctions -> {"Log2", None}]

Print[Style["Various constants:", "Section"]]
Print["linear min:"]
N[kLinearMin, 20]
Print["linear max:"]
N[kLinearMax, 20]
Print["log2 min:"]
N[kLog2Min, 20]
Print["log2 max:"]
N[kLog2Max, 20]

Print["agxCurve at min:"]
agxCurve[kLinearMin]
Print["agxCurve at middle grey:"]
N[agxCurve[kMidGray]]
Print["agxCurve at max:"]
agxCurve[kLinearMax]